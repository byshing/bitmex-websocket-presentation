<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitMEX WebSocket Data & State Management</title>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/black.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/monokai.min.css">
    
    <style>
        .reveal .slides section {
            text-align: left;
        }
        .reveal h1, .reveal h2, .reveal h3 {
            text-align: center;
        }
        .code-small {
            font-size: 0.8em;
        }
        .highlight-yellow {
            background-color: #ffd700;
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
        }
        .data-flow {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }
        .data-box {
            background: #2d3748;
            border: 2px solid #4a5568;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
            min-width: 200px;
            text-align: center;
        }
        .arrow {
            font-size: 2em;
            color: #ffd700;
        }
        .fragment.highlight-current-blue .visible {
            color: #51a7e8;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            
            <!-- Title Slide -->
            <section>
                <h1>BitMEX WebSocket</h1>
                <h2>Data Types & State Management</h2>
                <p style="text-align: center;">
                    <small>Understanding real-time data streams and state synchronization</small>
                </p>
            </section>

            <!-- Introduction to BitMEX WebSocket -->
            <section>
                <section>
                    <h2>What is BitMEX WebSocket?</h2>
                    <ul>
                        <li class="fragment">Real-time streaming data from BitMEX exchange</li>
                        <li class="fragment">Low-latency updates for trading applications</li>
                        <li class="fragment">Efficient state synchronization mechanism</li>
                        <li class="fragment">Various data types: orders, positions, executions, market data</li>
                    </ul>
                </section>

                <section>
                    <h3>WebSocket Connection Overview</h3>
                    <pre><code class="javascript" data-trim>
const WebSocket = require('ws');

const ws = new WebSocket('wss://ws.bitmex.com/realtime');

ws.on('open', () => {
    // Subscribe to data feeds
    ws.send(JSON.stringify({
        op: 'subscribe',
        args: ['orderBookL2:XBTUSD', 'execution:XBTUSD']
    }));
});

ws.on('message', (data) => {
    const message = JSON.parse(data);
    handleMessage(message);
});
                    </code></pre>
                </section>
            </section>

            <!-- Data Operation Types -->
            <section>
                <section>
                    <h2>WebSocket Data Operation Types</h2>
                    <div class="data-flow">
                        <div class="data-box fragment">
                            <h4>PARTIAL</h4>
                            <p>Initial snapshot</p>
                        </div>
                        <div class="arrow fragment">â†’</div>
                        <div class="data-box fragment">
                            <h4>INSERT</h4>
                            <p>New records</p>
                        </div>
                        <div class="arrow fragment">â†’</div>
                        <div class="data-box fragment">
                            <h4>UPDATE</h4>
                            <p>Modify existing</p>
                        </div>
                        <div class="arrow fragment">â†’</div>
                        <div class="data-box fragment">
                            <h4>DELETE</h4>
                            <p>Remove records</p>
                        </div>
                    </div>
                </section>

                <!-- PARTIAL Operation -->
                <section>
                    <h3>PARTIAL - Initial Data Snapshot</h3>
                    <ul>
                        <li class="fragment">First message received after subscription</li>
                        <li class="fragment">Contains complete current state</li>
                        <li class="fragment">Establishes baseline for incremental updates</li>
                    </ul>
                    
                    <pre class="fragment"><code class="json code-small" data-trim>
{
  "table": "orderBookL2",
  "action": "partial",
  "keys": ["symbol", "id", "side"],
  "types": {
    "symbol": "symbol",
    "id": "long", 
    "side": "symbol",
    "size": "long",
    "price": "float"
  },
  "foreignKeys": {
    "symbol": "instrument",
    "side": "side"
  },
  "attributes": {
    "symbol": "grouped",
    "id": "sorted"
  },
  "filter": {
    "symbol": "XBTUSD"
  },
  "data": [
    {"symbol": "XBTUSD", "id": 8790000000, "side": "Sell", "size": 1000, "price": 50000},
    {"symbol": "XBTUSD", "id": 8790000001, "side": "Buy", "size": 2000, "price": 49999}
  ]
}
                    </code></pre>
                </section>

                <!-- PARTIAL Fields Explanation -->
                <section>
                    <h3>Understanding PARTIAL Fields</h3>
                    <div style="font-size: 0.9em;">
                        <div class="fragment">
                            <strong class="highlight-yellow">keys</strong>: Unique identifiers for each record
                            <pre><code>"keys": ["symbol", "id", "side"]</code></pre>
                        </div>
                        
                        <div class="fragment">
                            <strong class="highlight-yellow">types</strong>: Data type definitions
                            <pre><code>"types": {"symbol": "symbol", "id": "long", "price": "float"}</code></pre>
                        </div>
                        
                        <div class="fragment">
                            <strong class="highlight-yellow">foreignKeys</strong>: References to other tables
                            <pre><code>"foreignKeys": {"symbol": "instrument"}</code></pre>
                        </div>
                        
                        <div class="fragment">
                            <strong class="highlight-yellow">attributes</strong>: Special properties (grouped, sorted)
                            <pre><code>"attributes": {"symbol": "grouped", "id": "sorted"}</code></pre>
                        </div>
                        
                        <div class="fragment">
                            <strong class="highlight-yellow">filter</strong>: Applied filters for this subscription
                            <pre><code>"filter": {"symbol": "XBTUSD"}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- INSERT Operation -->
                <section>
                    <h3>INSERT - Adding New Records</h3>
                    <ul>
                        <li class="fragment">Adds new records to the dataset</li>
                        <li class="fragment">Common in execution feeds, new orders</li>
                        <li class="fragment">Use keys to determine insertion point</li>
                    </ul>
                    
                    <pre class="fragment"><code class="json code-small" data-trim>
{
  "table": "execution",
  "action": "insert",
  "data": [
    {
      "execID": "abc12345-def6-7890-ghij-klmn12345678",
      "symbol": "XBTUSD",
      "side": "Buy",
      "lastQty": 100,
      "lastPx": 50000,
      "execType": "Trade",
      "timestamp": "2025-08-16T10:30:00.000Z"
    }
  ]
}
                    </code></pre>

                    <div class="fragment">
                        <h4>Code Example: Handling INSERT</h4>
                        <pre><code class="javascript code-small" data-trim>
function handleInsert(table, data) {
    data.forEach(record => {
        if (table === 'execution') {
            // Add to execution history
            executionHistory.push(record);
            updateTradeStatistics(record);
        } else if (table === 'orderBookL2') {
            // Insert into order book at correct position
            insertOrderBookLevel(record);
        }
    });
}
                        </code></pre>
                    </div>
                </section>

                <!-- UPDATE Operation -->
                <section>
                    <h3>UPDATE - Modifying Existing Records</h3>
                    <ul>
                        <li class="fragment">Updates existing records by key</li>
                        <li class="fragment">Only modified fields are included</li>
                        <li class="fragment">Common for positions, margins, order book</li>
                    </ul>
                    
                    <pre class="fragment"><code class="json code-small" data-trim>
{
  "table": "position",
  "action": "update", 
  "data": [
    {
      "symbol": "XBTUSD",
      "currentQty": 500,  // Only changed fields
      "unrealisedPnl": 125000,
      "timestamp": "2025-08-16T10:30:01.000Z"
    }
  ]
}
                    </code></pre>

                    <div class="fragment">
                        <h4>Code Example: Handling UPDATE</h4>
                        <pre><code class="javascript code-small" data-trim>
function handleUpdate(table, data, keys) {
    data.forEach(updateData => {
        const existing = findRecordByKeys(table, updateData, keys);
        if (existing) {
            // Merge update data into existing record
            Object.assign(existing, updateData);
            
            if (table === 'position') {
                updatePositionDisplay(existing);
            } else if (table === 'orderBookL2') {
                updateOrderBookLevel(existing);
            }
        }
    });
}
                        </code></pre>
                    </div>
                </section>

                <!-- DELETE Operation -->
                <section>
                    <h3>DELETE - Removing Records</h3>
                    <ul>
                        <li class="fragment">Removes records identified by keys</li>
                        <li class="fragment">Common for cancelled orders, filled order book levels</li>
                        <li class="fragment">Only key fields are provided</li>
                    </ul>
                    
                    <pre class="fragment"><code class="json code-small" data-trim>
{
  "table": "orderBookL2",
  "action": "delete",
  "data": [
    {
      "symbol": "XBTUSD",
      "id": 8790000000,
      "side": "Sell"
    }
  ]
}
                    </code></pre>

                    <div class="fragment">
                        <h4>Code Example: Handling DELETE</h4>
                        <pre><code class="javascript code-small" data-trim>
function handleDelete(table, data, keys) {
    data.forEach(deleteData => {
        const index = findRecordIndexByKeys(table, deleteData, keys);
        if (index !== -1) {
            const record = tableData[table].splice(index, 1)[0];
            
            if (table === 'orderBookL2') {
                removeOrderBookLevel(record);
                updateOrderBookDisplay();
            } else if (table === 'order') {
                notifyOrderCancelled(record);
            }
        }
    });
}
                        </code></pre>
                    </div>
                </section>
            </section>

            <!-- Feed Types -->
            <section>
                <section>
                    <h2>Types of WebSocket Feeds</h2>
                    <div class="data-flow">
                        <div class="data-box fragment">
                            <h4>ðŸ“ˆ Infinite Insert</h4>
                            <p>Execution, Trade</p>
                            <small>Continuous new records</small>
                        </div>
                        <div class="data-box fragment">
                            <h4>ðŸ”„ State Update</h4>
                            <p>Position, Margin</p>
                            <small>Few records, frequent updates</small>
                        </div>
                        <div class="data-box fragment">
                            <h4>ðŸ“Š Order Book</h4>
                            <p>OrderBookL2</p>
                            <small>Insert/Update/Delete mix</small>
                        </div>
                    </div>
                </section>

                <!-- Infinite Insert Feeds -->
                <section>
                    <h3>Infinite Insert Feeds</h3>
                    <div class="fragment">
                        <h4>Characteristics:</h4>
                        <ul>
                            <li>Primarily INSERT operations</li>
                            <li>Historical data grows continuously</li>
                            <li>Each record represents a distinct event</li>
                            <li>Examples: <code>execution</code>, <code>trade</code></li>
                        </ul>
                    </div>

                    <div class="fragment">
                        <h4>Management Strategy:</h4>
                        <pre><code class="javascript code-small" data-trim>
class ExecutionManager {
    constructor(maxHistorySize = 1000) {
        this.executions = [];
        this.maxHistorySize = maxHistorySize;
    }

    handleMessage(message) {
        if (message.action === 'insert') {
            // Add new executions
            this.executions.push(...message.data);
            
            // Maintain size limit
            if (this.executions.length > this.maxHistorySize) {
                this.executions = this.executions.slice(-this.maxHistorySize);
            }
            
            // Process new executions
            this.processNewExecutions(message.data);
        }
    }

    processNewExecutions(executions) {
        executions.forEach(exec => {
            this.updateTradeVolume(exec);
            this.notifyTradeListeners(exec);
        });
    }
}
                        </code></pre>
                    </div>
                </section>

                <!-- State Update Feeds -->
                <section>
                    <h3>State Update Feeds</h3>
                    <div class="fragment">
                        <h4>Characteristics:</h4>
                        <ul>
                            <li>Few records (often just 1-3 per symbol)</li>
                            <li>Frequent UPDATE operations</li>
                            <li>Represents current state</li>
                            <li>Examples: <code>position</code>, <code>margin</code>, <code>wallet</code></li>
                        </ul>
                    </div>

                    <div class="fragment">
                        <h4>Management Strategy:</h4>
                        <pre><code class="javascript code-small" data-trim>
class PositionManager {
    constructor() {
        this.positions = new Map(); // symbol -> position
    }

    handleMessage(message) {
        switch (message.action) {
            case 'partial':
                // Initialize positions
                message.data.forEach(pos => {
                    this.positions.set(pos.symbol, pos);
                });
                break;
                
            case 'update':
                // Update existing positions
                message.data.forEach(update => {
                    const existing = this.positions.get(update.symbol);
                    if (existing) {
                        Object.assign(existing, update);
                        this.notifyPositionChange(existing);
                    }
                });
                break;
                
            case 'delete':
                // Remove closed positions
                message.data.forEach(del => {
                    this.positions.delete(del.symbol);
                });
                break;
        }
    }
}
                        </code></pre>
                    </div>
                </section>

                <!-- Order Book Feeds -->
                <section>
                    <h3>Order Book Feeds</h3>
                    <div class="fragment">
                        <h4>Characteristics:</h4>
                        <ul>
                            <li>Mixed operations: INSERT, UPDATE, DELETE</li>
                            <li>Requires sorted maintenance</li>
                            <li>High frequency updates</li>
                            <li>Examples: <code>orderBookL2</code>, <code>orderBook10</code></li>
                        </ul>
                    </div>

                    <div class="fragment">
                        <h4>Management Strategy:</h4>
                        <pre><code class="javascript code-small" data-trim>
class OrderBookManager {
    constructor() {
        this.orderBook = {
            bids: new Map(), // price -> {size, orders}
            asks: new Map()
        };
    }

    handleMessage(message) {
        switch (message.action) {
            case 'partial':
                this.initializeOrderBook(message.data);
                break;
            case 'insert':
                this.insertLevels(message.data);
                break;
            case 'update':
                this.updateLevels(message.data);
                break;
            case 'delete':
                this.deleteLevels(message.data);
                break;
        }
        this.notifyOrderBookChange();
    }

    insertLevels(levels) {
        levels.forEach(level => {
            const side = level.side === 'Buy' ? 'bids' : 'asks';
            this.orderBook[side].set(level.price, {
                size: level.size,
                id: level.id
            });
        });
    }
}
                        </code></pre>
                    </div>
                </section>
            </section>

            <!-- Complete Example -->
            <section>
                <section>
                    <h2>Complete Implementation Example</h2>
                    <pre><code class="javascript code-small" data-trim>
class BitMEXWebSocketManager {
    constructor() {
        this.ws = null;
        this.tables = new Map();
        this.tableConfigs = new Map();
    }

    connect() {
        this.ws = new WebSocket('wss://ws.bitmex.com/realtime');
        
        this.ws.on('message', (data) => {
            const message = JSON.parse(data);
            this.handleMessage(message);
        });
    }

    subscribe(feeds) {
        this.ws.send(JSON.stringify({
            op: 'subscribe',
            args: feeds
        }));
    }

    handleMessage(message) {
        if (!message.table) return;

        switch (message.action) {
            case 'partial':
                this.handlePartial(message);
                break;
            case 'insert':
                this.handleInsert(message);
                break;
            case 'update':
                this.handleUpdate(message);
                break;
            case 'delete':
                this.handleDelete(message);
                break;
        }
    }
}
                    </code></pre>
                </section>

                <section>
                    <h3>Usage Example</h3>
                    <pre><code class="javascript code-small" data-trim>
// Initialize manager
const wsManager = new BitMEXWebSocketManager();

// Set up event listeners
wsManager.on('position:update', (positions) => {
    updatePositionDisplay(positions);
});

wsManager.on('execution:new', (executions) => {
    executions.forEach(exec => {
        addToTradeHistory(exec);
        updatePnL(exec);
    });
});

wsManager.on('orderbook:change', (orderBook) => {
    updateOrderBookDisplay(orderBook);
    calculateSpread(orderBook);
});

// Connect and subscribe
wsManager.connect();
wsManager.subscribe([
    'position',
    'margin', 
    'execution:XBTUSD',
    'orderBookL2:XBTUSD'
]);
                    </code></pre>
                </section>
            </section>

            <!-- Best Practices -->
            <section>
                <h2>Best Practices</h2>
                <ul>
                    <li class="fragment"><strong>State Management</strong>: Keep local state synchronized with WebSocket updates</li>
                    <li class="fragment"><strong>Error Handling</strong>: Implement reconnection logic and data validation</li>
                    <li class="fragment"><strong>Performance</strong>: Use efficient data structures (Maps, sorted arrays)</li>
                    <li class="fragment"><strong>Memory Management</strong>: Limit history size for infinite insert feeds</li>
                    <li class="fragment"><strong>UI Updates</strong>: Debounce high-frequency updates for better UX</li>
                    <li class="fragment"><strong>Data Integrity</strong>: Always use keys to identify records correctly</li>
                </ul>
            </section>

            <!-- Q&A -->
            <section>
                <h1>Questions & Discussion</h1>
                <div style="text-align: center; margin-top: 50px;">
                    <h3>Thank you!</h3>
                    <p>BitMEX WebSocket Data & State Management</p>
                </div>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/highlight/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/notes/notes.min.js"></script>
    
    <script>
        Reveal.initialize({
            hash: true,
            transition: 'slide',
            plugins: [RevealHighlight, RevealNotes],
            highlight: {
                beforeHighlight: (hljs) => {
                    hljs.registerLanguage('json', function(hljs) {
                        return {
                            contains: [
                                hljs.QUOTE_STRING_MODE,
                                hljs.C_NUMBER_MODE,
                                {
                                    className: 'literal',
                                    begin: '\\b(true|false|null)\\b'
                                },
                                {
                                    className: 'attr',
                                    begin: '"[^"]*"\\s*:'
                                }
                            ]
                        };
                    });
                }
            }
        });
    </script>
</body>
</html>
